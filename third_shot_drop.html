<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickleball Baseline vs Kitchen - Isometric View</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: system-ui, -apple-system, sans-serif;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div id="ui">
    <h1 class="text-xl font-bold opacity-80">Baseline vs. Kitchen Drill</h1>
    <p class="text-sm opacity-60">Red: 3rd Shot Drop | Blue: Baseline Return</p>
</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    const courtColor = '#2d5a27';
    const kitchenColor = '#3a7a33';
    
    let traces = []; 
    let ripples = [];

    function project(x, y, z = 0) {
        const isoX = (x - y) * Math.cos(Math.PI / 6);
        const isoY = (x + y) * Math.sin(Math.PI / 6) - z;
        return {
            x: width / 2 + isoX,
            y: height / 2 + isoY - 50 
        };
    }

    const ball = {
        x: 0, y: 0, z: 0,
        startX: 0, startY: 0,
        bounceX: 0, bounceY: 0,
        targetX: 0, targetY: 0,
        progress: 1,
        speed: 0.012,
        radius: 6,
        color: '#efff00',
        state: 'flying',
        tNet: 0.5,
        peakZ: 60
    };

    const kitchenLen = 63; 
    const serviceLen = 135; 
    const courtHalfLen = kitchenLen + serviceLen; 
    const courtWidth = 90; 
    const netHeight = 32; 

    const paddles = {
        top: { x: 0, y: 0, targetX: 0, currentX: 0, yPos: -kitchenLen - 12 },
        bottom: { x: 0, y: 0, targetX: 0, currentX: 0, yPos: courtHalfLen - 8 }
    };

    function init() {
        resize();
        resetBall();
        animate();
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }

    function resetBall() {
        ball.x = 0;
        ball.y = paddles.bottom.yPos;
        ball.progress = 1;
        planNextShot();
    }

    function planNextShot() {
        traces = [];
        ball.startX = ball.x;
        ball.startY = ball.y;
        ball.progress = 0;
        ball.state = 'flying';
        
        const isRedHitting = ball.startY > 0;
        const nextYDir = isRedHitting ? -1 : 1;
        
        if (isRedHitting) {
            ball.bounceX = (Math.random() - 0.5) * courtWidth * 1.2;
            ball.bounceY = nextYDir * (Math.random() * (kitchenLen - 25) + 10);
            ball.speed = 0.009; 
        } else {
            ball.bounceX = (Math.random() - 0.5) * courtWidth * 1.5;
            ball.bounceY = nextYDir * (courtHalfLen - (Math.random() * 40 + 10));
            ball.speed = 0.016; 
        }

        const nextSide = isRedHitting ? 'top' : 'bottom';
        const contactLineY = isRedHitting ? (-kitchenLen - 12) : (courtHalfLen - 8);
        
        ball.targetX = ball.bounceX + (ball.bounceX - ball.startX) * 0.1;
        ball.targetY = contactLineY;

        ball.tNet = Math.abs(ball.startY) / (Math.abs(ball.startY) + Math.abs(ball.bounceY));
        const minH = (netHeight + 18) / (4 * ball.tNet * (1 - ball.tNet));
        ball.peakZ = isRedHitting ? Math.max(minH, 75) : Math.max(minH, 45);

        paddles[nextSide].targetX = ball.targetX;
    }

    function drawCourt() {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);

        const p1 = project(-courtWidth, -courtHalfLen);
        const p2 = project(courtWidth, -courtHalfLen);
        const p3 = project(courtWidth, courtHalfLen);
        const p4 = project(-courtWidth, courtHalfLen);

        ctx.fillStyle = courtColor;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.closePath();
        ctx.fill();

        const drawKitchen = (yStart, yEnd) => {
            const k1 = project(-courtWidth, yStart);
            const k2 = project(courtWidth, yStart);
            const k3 = project(courtWidth, yEnd);
            const k4 = project(-courtWidth, yEnd);
            ctx.fillStyle = kitchenColor;
            ctx.beginPath();
            ctx.moveTo(k1.x, k1.y); ctx.lineTo(k2.x, k2.y); ctx.lineTo(k3.x, k3.y); ctx.lineTo(k4.x, k4.y); ctx.closePath();
            ctx.fill();
        };
        drawKitchen(-kitchenLen, 0);
        drawKitchen(0, kitchenLen);

        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.closePath();
        ctx.stroke();

        const kl1 = project(-courtWidth, -kitchenLen);
        const kl2 = project(courtWidth, -kitchenLen);
        ctx.beginPath(); ctx.moveTo(kl1.x, kl1.y); ctx.lineTo(kl2.x, kl2.y); ctx.stroke();
        
        const kl3 = project(-courtWidth, kitchenLen);
        const kl4 = project(courtWidth, kitchenLen);
        ctx.beginPath(); ctx.moveTo(kl3.x, kl3.y); ctx.lineTo(kl4.x, kl4.y); ctx.stroke();

        [[0, -kitchenLen, 0, -courtHalfLen], [0, kitchenLen, 0, courtHalfLen]].forEach(l => {
            const s = project(l[0], l[1]); const e = project(l[2], l[3]);
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        });
    }

    function drawNet() {
        const xStart = -courtWidth - 10;
        const xEnd = courtWidth + 10;
        
        // RESTORED: Mesh grid density and opacity to match original dink.html
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        
        // Vertical mesh lines (restored to 8 units)
        for (let x = xStart; x <= xEnd; x += 8) {
            const b = project(x, 0, 0); const t = project(x, 0, netHeight);
            ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(t.x, t.y); ctx.stroke();
        }
        // Horizontal mesh lines (restored to 8 units)
        for (let z = 0; z <= netHeight; z += 8) {
            const left = project(xStart, 0, z);
            const right = project(xEnd, 0, z);
            ctx.beginPath(); ctx.moveTo(left.x, left.y); ctx.lineTo(right.x, right.y); ctx.stroke();
        }

        // Net Top Tape
        const n1t = project(xStart, 0, netHeight);
        const n2t = project(xEnd, 0, netHeight);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(n1t.x, n1t.y); ctx.lineTo(n2t.x, n2t.y); ctx.stroke();
        
        // Side Posts
        [xStart, xEnd].forEach(x => {
            const b = project(x, 0, 0); const t = project(x, 0, netHeight);
            ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(t.x, t.y); ctx.stroke();
        });
    }

    function drawRipples() {
        ripples.forEach((r, i) => {
            const p = project(r.x, r.y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${r.alpha})`;
            ctx.beginPath(); ctx.ellipse(p.x, p.y, r.s, r.s/2, 0, 0, Math.PI * 2); ctx.stroke();
            r.s += 1.2; r.alpha -= 0.025;
            if (r.alpha <= 0) ripples.splice(i, 1);
        });
    }

    function drawTraces() {
        if (traces.length < 2) return;
        ctx.strokeStyle = 'rgba(239, 255, 0, 0.2)';
        ctx.beginPath();
        const start = project(traces[0].x, traces[0].y, traces[0].z);
        ctx.moveTo(start.x, start.y);
        for (let i = 1; i < traces.length; i++) {
            const p = project(traces[i].x, traces[i].y, traces[i].z);
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }

    function drawPaddle(side) {
        const p = paddles[side];
        p.currentX += (p.targetX - p.currentX) * 0.1;
        const pos = project(p.currentX, p.yPos, 12); 
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.fillStyle = side === 'top' ? '#3b82f6' : '#ef4444';
        ctx.beginPath(); ctx.roundRect(-12, -18, 24, 36, 6); ctx.fill();
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5; ctx.stroke();
        ctx.fillStyle = '#333'; ctx.fillRect(-3, (side === 'top' ? -30 : 18), 6, 12);
        ctx.restore();
    }

    function update() {
        if (ball.progress < 1) {
            ball.progress += ball.speed;
            const bounceThreshold = 0.75; 

            if (ball.state === 'flying' && ball.progress >= bounceThreshold) {
                ball.state = 'rebounding';
                ripples.push({ x: ball.bounceX, y: ball.bounceY, s: 2, alpha: 1 });
            }

            if (ball.progress >= 1) {
                ball.progress = 1;
                planNextShot();
            }

            if (ball.state === 'flying') {
                const t = ball.progress / bounceThreshold;
                ball.x = ball.startX + (ball.bounceX - ball.startX) * t;
                ball.y = ball.startY + (ball.bounceY - ball.startY) * t;
                ball.z = 4 * ball.peakZ * t * (1 - t);
            } else {
                const t = (ball.progress - bounceThreshold) / (1 - bounceThreshold);
                ball.x = ball.bounceX + (ball.targetX - ball.bounceX) * t;
                ball.y = ball.bounceY + (ball.targetY - ball.bounceY) * t;
                ball.z = Math.sin(t * (Math.PI / 2)) * 12; 
            }
            traces.push({ x: ball.x, y: ball.y, z: ball.z });
        }
    }

    function drawBall() {
        const shadowPos = project(ball.x, ball.y, 0);
        const ballPos = project(ball.x, ball.y, ball.z);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(shadowPos.x, shadowPos.y, 7, 3.5, 0, 0, Math.PI * 2); ctx.fill();
        const size = ball.radius + (ball.z * 0.04);
        const grad = ctx.createRadialGradient(ballPos.x - 2, ballPos.y - 2, 1, ballPos.x, ballPos.y, size);
        grad.addColorStop(0, '#ffffcc'); grad.addColorStop(1, ball.color);
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(ballPos.x, ballPos.y, size, 0, Math.PI * 2); ctx.fill();
    }

    function animate() {
        drawCourt();
        drawRipples();
        drawTraces();
        drawNet();
        drawPaddle('top');
        drawPaddle('bottom');
        update();
        drawBall();
        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    window.onload = init;
</script>
</body>
</html>
